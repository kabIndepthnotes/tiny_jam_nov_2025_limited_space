@code_type gdscript .gd
@comment_type # %s

@s mc.gd

--- mc.gd
extends CharacterBody2D
@{export_vars}
@{onready_vars}
@{vars}
@{builtin_functions}
@{custom_functions}
---

@s movement
--- vars
var tile_size = 8 * 4 # 8 pixels scaled by 4
var player_size = Vector2(14 * 4, 20 * 4)
---

--- export_vars
@export var speed = 300.0
---


--- builtin_functions
func _ready():
	@{_ready}

func _unhandled_input(event):
	@{_unhandled_input}
	
# func _physics_process(delta: float) -> void:
# 	@{_physics_process}
---

credit: https://kidscancode.org/godot_recipes/4.x/2d/grid_movement/index.html
We start at the middle.
--- _ready
position = position.snapped(Vector2.ONE * tile_size)
position.x += tile_size / 2
---

Second item in array is the area2d stuff.
--- vars +=
var inputs = {"move_right": Vector2.RIGHT,
            "move_left": Vector2.LEFT,
            "move_up": Vector2.UP,
            "move_down": Vector2.DOWN,
}
---

--- _unhandled_input
for dir in inputs.keys():
	if event.is_action_pressed(dir):
		move(dir)
---
 

Before we actually move the player we want to `clamp` the player to the room and not allow him to move outside it.

--- vars +=
---

--- _ready +=
---

We now have to actually move the player

--- custom_functions
@{f_move}
---

--- f_move
func move(dir):
	position += inputs[dir] * tile_size
---


@s facing direction for interaction
--- vars +=
var facing_direction = Vector2.DOWN # Track current facing direction
---

--- _ready +=
---

--- f_move :=
func move(dir):
	var movement = inputs[dir] * tile_size
	var collision = move_and_collide(movement, true)
	if collision == null:
		position += movement
---


--- custom_functions +=
---


@s debug
--- _ready +=
print(position.x)
---

@s interaction

--- _ready +=
var interact_area = $InteractionComponent/InteractionArea
interact_area.area_entered.connect(_on_interact_area_entered)
interact_area.area_exited.connect(_on_interact_area_exited)
---

--- onready_vars
@onready var all_interactions = []
---


--- custom_functions +=
func _on_interact_area_entered(area):
	all_interactions.insert(0,area)
	print("entered") # debug
	update_interactions()

func _on_interact_area_exited(area):
	all_interactions.erase(area)
	update_interactions()
---

--- onready_vars +=
@onready var interactLabel = $InteractionComponent/InteractLabel
---


--- custom_functions +=

func update_interactions():
	if all_interactions: # if all_interactions is non-empty
		interactLabel.text = all_interactions[0].interact_label # from interact_area scene
	else:
		interactLabel.text = ""
---

Remove text appearing at the start

--- _ready +=
update_interactions()
---

--- custom_functions +=
func execute_interactions():
	if all_interactions:
		var cur_interaction = all_interactions[0]
		match cur_interaction.interact_type:
			"print_text": print(cur_interaction.interact_value)
			"open_drawer": obtain_cell_battery()
			"open_puzzle_2": run_puzzle_2()
---


Add input

--- _unhandled_input +=
if event.is_action_pressed("interact"):
	execute_interactions()
---

--- export_vars +=
@export var has_cell_battery = false
---


--- custom_functions +=
func obtain_cell_battery():
	if not has_cell_battery:
		has_cell_battery = true
		interactLabel.text = "A Cell battery!"
		# print("cell battery obtained")
---

--- custom_functions +=
func run_puzzle_2():
	get_tree().change_scene_to_file("res://scenes/safe_1.tscn")
---


