@code_type gdscript .gd
@comment_type # %s

@s mc.gd

--- mc.gd
extends CharacterBody2D
@{export_vars}
@{vars}
@{builtin_functions}
@{custom_functions}
---

@s movement
--- vars
var tile_size = 8 * 4 # 8 pixels scaled by 4
var player_size = Vector2(14 * 4, 20 * 4)
---

--- export_vars
@export var speed = 300.0
---


--- builtin_functions
func _ready():
	@{_ready}

func _unhandled_input(event):
	@{_unhandled_input}
	
# func _physics_process(delta: float) -> void:
	# @{_physics_process}
---

credit: https://kidscancode.org/godot_recipes/4.x/2d/grid_movement/index.html
We start at the middle.
--- _ready
position = position.snapped(Vector2.ONE * tile_size)
position.x += tile_size / 2
---

Second item in array is the area2d stuff.
--- vars +=
var inputs = {"move_right": [Vector2.RIGHT, Vector2(player_size.x / 2, player_size.y / 2)],
            "move_left": [Vector2.LEFT, Vector2(-player_size.x / 2, player_size.y / 2)],
            "move_up": [Vector2.UP, Vector2(player_size.x / 2, 0)],
            "move_down": [Vector2.DOWN, Vector2(player_size.x / 2 , player_size.y)],
}
---

--- _unhandled_input
for dir in inputs.keys():
	if event.is_action_pressed(dir):
		move(dir)
---


Before we actually move the player we want to `clamp` the player to the room and not allow him to move outside it.

--- vars +=
---

--- _ready +=
---

We now have to actually move the player

--- custom_functions
@{f_move}
---

--- f_move
func move(dir):
	position += inputs[dir][0] * tile_size
---


@s facing direction for interaction
--- vars +=
var facing_direction = Vector2.DOWN # Track current facing direction
---

--- _ready +=
---

--- f_move :=
func move(dir):
	var movement = inputs[dir][0] * tile_size
	$Area2D.position = inputs[dir][1]
	var collision = move_and_collide(movement, true)
	if collision == null:
		position += movement
---


--- custom_functions +=
---




@s debug
--- _ready +=
print(position.x)
---

